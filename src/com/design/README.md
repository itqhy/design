# Design (设计模式)

	一、什么是设计模式
	设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。
	
	二、设计模式的类型
	根据设计模式的参考书（设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：
		创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。
	1、创建型模式
	这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用新的运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。
	具体包括：
		工厂模式（Factory Pattern）
		抽象工厂模式（Abstract Factory Pattern）
		单例模式（Singleton Pattern）
		建造者模式（Builder Pattern）
		原型模式（Prototype Pattern）
	2、结构型模式
	这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。
	具体包括：
		适配器模式（Adapter Pattern）
		桥接模式（Bridge Pattern）
		过滤器模式（Filter、Criteria Pattern）
		组合模式（Composite Pattern）
		装饰器模式（Decorator Pattern）
		外观模式（Facade Pattern）
		享元模式（Flyweight Pattern）
		代理模式（Proxy Pattern）
	3、行为型模式
	这些设计模式特别关注对象之间的通信。
	具体包括：
		责任链模式（Chain of Responsibility Pattern）
		命令模式（Command Pattern）
		解释器模式（Interpreter Pattern）
		迭代器模式（Iterator Pattern）
		中介者模式（Mediator Pattern）
		备忘录模式（Memento Pattern）
		观察者模式（Observer Pattern）
		状态模式（State Pattern）
		空对象模式（Null Object Pattern）
		策略模式（Strategy Pattern）
		模板模式（Template Pattern）
		访问者模式（Visitor Pattern）
		
	三、设计模式的六大原则
	1、开闭原则（Open Close Principle）
	开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。  
	2、里氏代换原则（Liskov Substitution Principle）
	里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
	3、依赖倒转原则（Dependence Inversion Principle）
	这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。也就是说要把业务尽量封装为接口，而不要在程序中直接编写具体实现。
	4、接口隔离原则（Interface Segregation Principle）
	这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。
	5、迪米特法则，又称最少知道原则（Demeter Principle）
	最少知道原则是指：一个实体类应当尽量少地与其他实体类之间发生相互作用，使得系统功能模块相对独立。
	6、合成复用原则（Composite Reuse Principle）
	合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。

## 工厂模式  (com.design.factory)

### 分类
	分为三种：
		简单工厂模式
		工厂方法模式
		抽象工厂模式

### 区别
	工厂方法模式：
		一个抽象产品类，可以派生出多个具体产品类
		一个抽象工厂类，可以派生出多个具体工厂类
		每个具体工厂类只能创建一个具体产品类的实例
	抽象工厂模式：
		多个抽象产品类，每个抽象产品类可以派生出多个具体产品类
		一个抽象工厂类，可以派生出多个具体工厂类
		每个具体工厂类可以创建多个具体产品类的实例
	区别：
		工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个
		工厂方法模式具体工厂类智能创建一个具体产品类的实例，而抽象工厂模式可以创建多个
		

## 单例模式 (com.design.singleton)

	分为两种 ：饿汉式 和懒汉式
	懒汉式：指全局的单例实例在第一次被使用时构建。
	饿汉式：指全局的单例实例在类装载时构建。
	

	具体实现：synchornized、双重检查锁定、静态内部类

## 建造者模式(com.design.builder)
	将一个复杂的对象的构建与它的表示分离，是的同样的构建过程可以创建不同的表示。
	工厂类模式提供的是创建单个类的模式，而建造者模式是将各种产品几种起来进行管理，用来创建复合对象，所谓复合对象就是指某
	个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的。
	
	建造者模式通常包括下面几个角色：
	
	1、Builder:给出一个抽象接口，以规范产品对象的各个组成成分的建造，这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。
	2、ConcreteBuilder:实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。在建造的过程完成后，提供产品的实例。
	3、Director:调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，之负责保证对象个部分完整创建或按某种顺序创建。
	4、Product:要创建的复杂对象。
	
	应用实例：
	1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 
	2、JAVA 中的 StringBuilder。
	
	使用场景：
	1、需要生成对象具有复杂的内部结构。
	2、需要生成的对象内部属性本身相互依赖。
	
	与工厂模式的区别是：建造者模式更加关注零件装配的顺序。
	
## 原型模式 (com.design.prototype )

	原型模式是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，他提供了一种创建对象的最佳方式。
	这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，
	一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

	使用场景：
		1、资源优化场景。
		2、类的初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。
		3、性能和安全要求的场景。
		4、通过new产生一个对象需要非常繁琐的数据准备或访问全向，则可以使用原型模式。
		5、一个对象多个修改者的场景。
		6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改值时，可以考虑使用原型模式拷贝多个对象供调用者使用。
		7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone方法创建一个对象，让然后由工厂方法提供给调用者。
		
		
	注意事项：
		与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有的对象生成新的对象，
		浅复制实现Cloneable,重写clone方法，浅复制是通过Serializable读取二进制流。
		
		
	实现方式：
		浅复制实现：浅复制将对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。
		深复制实现： 深复制对象后，不论是基本数据类型还是引用类型都会重新创建，深复制进行了完全彻底的复制，而浅复制不彻底。
		
## 适配器模式(com.design.adapter)

	适配器模式的基本作用是将一个类的接口转换成客户希望的另外一个接口，使得原先由于接口不兼容而不能一起工作的那些类可以在一起工作。
	
	模式中的角色：
		1、目标接口（Target） ：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。
		2、需要适配的类（Adaptee): 需要适配的类或适配者类。
		3、适配器（Adapter):通过包装一个需要适配的对象，把原接口转换成目标接口。
	
	何时使用适配器模式？
		1、系统需要使用现有的类，但此类的接口不符合系统的需要。
		2、想要建立一个可以重复使用的类，用于一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。
		3、通过接口的转换，将一个类插入另一个类系中。
		4、两个类所做的事情相同或相似，但具有不同接口的时候。
		5、旧的系统开发的类已经实现了一些功能，但是客户端却只能以另外接口的形式访问，但我们不希望手动更改现有类的时候。
		6、使用第三方组件，组件接口定义和自己定义的不同，不希望修改自己的接口，但是要使用第三方接口的功能。
		
	应用实例：
		1、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的
		 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 
		2、在 LINUX 上运行 WINDOWS 程序。 
		3、JAVA 中的 jdbc。

## 桥接模式(com.design.bridge)	

	桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。
	这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。
	* 抽象化
	存在于多个实体中的共同的概念性联系，就是抽象化。作为一个过程，抽象化就是忽略一些信息，从而把不同的实体当做同样的实体对待。
	* 实现化
	抽象化给出的具体实现，就是实现化。
	* 解耦
	所谓耦合，就是两个实体的行为的某种强关联。而将它们的强关联去掉，就是耦合的解耦，或称脱耦。在这里，解耦是指将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联。
	将两个角色之间的继承关系改为聚合关系，就是将它们之间的强关联改换成为弱关联。因此，桥梁模式中的所谓解耦，就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以相对独立地变化。
	
	桥梁模式所涉及的角色有：
	1、抽象化(Abstraction)角色：抽象化给出的定义，并保存一个对实现化对象的引用。
	2、修正抽象化(Refined Abstraction)角色：扩展抽象化角色的接口，改变和修正父类对抽象化的定义。
	3、实现化(Implementor)角色：这个角色给出实现化角色的接口，但不给出具体的实现。这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。
	4、具体实现化(Concrete Implementor)角色：这个角色给出实现化角色接口的具体实现。
	
	使用场景： 
	1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 
	2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 
	3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。
	
	桥接模式的实现实例
	
	那就是画图，这里有一个画笔，可以画正方形、长方形、圆形（这个大家都知道怎么做吧，我就不解释了）。但是现在我们需要给这些形状进行上色，这里有三种颜色：白色、灰色、黑色。这里我们可以画出3*3=9中图形：白色正方形、白色长方形、白色圆形

## 过滤器模式(com.design.filter)
	过滤器模式（Filter）也叫标准模式（Criteria），这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。
	
	常见的通用实现方法是通过ArrayLiat来作为容器存放对象并利用对象的多态对其进行操作。

	设计思路：
		创建一个要过滤的类，普通类即可，要有获得其私有属性的get方法
		创建一个接口，规定过滤方法
		实现接口，可以依需要来实现过滤的条件（通过重写过滤方法），参数传递的可以说List<过滤类>类的容器
		复杂过滤类可以通过设置传递接口参数（复用其他基础过滤类）来实现多重过滤
		
## 组合模式(com.design.composite)
	组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构。composite 使得用户对单个对象和组合对象的使用具有一致性。有时候又叫部分-整体模式，他使我们树形结构的问题中，模糊了简单元素和浮躁元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。
	组合模式让我们可以优化处理递归或分级数据结构。有许多关于分级数据结构的例子，使得组合模式非常有用武之地。关于分级数据结构的一个普遍性的例子是你每次使用电脑时遇到的：文件系统。文件系统由目录和文件组成。每个目录都可以装内容。目录的内容可以是文件，也可以使目录。按照这种方式，计算机的文件系统就是以递归结构所组织的。如果你想要描述这样的数据结构，那么你可以使用组合模式composite.
	
	1、Component：是组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component子部件。
	2、Leaf:在组合中表示叶子节点对象，叶子节点没有子节点
	3、Composite:定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关的操作，如增加（add)和删除（remove)等。
	
	使用场景：
	1、表示对象的部分-整体层次结构(树形结构)如树形菜单，文件、文件夹的管理。
	2、用户忽略组合对象与单个对象的不同，用户统一地使用组合结构中的所有对象
	
	
## 装饰器模式(com.design.decorator)

	装饰器模式可以动态的给一个对象添加一些额外的职责，同时又不改变其内部结构。就像在墙上刷漆，使用Decorator模式相比用生成子类方式达到功能的扩充显得更为灵活。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。
	
	应用场景：
		1、在不修改源代码的情况下，扩张一个类的功能。
		2、实现动态增加功能，动态撤销。
		
	实例：
		假如现在需要一个汉堡，主体是鸡腿堡，我们可以选择添加生菜、酱、辣椒等等许多其他配料，同时根据所加的配料，重新计算价格。这种情况下就可以使用装饰者模式。
	
## 外观模式(com.design.facade)	

	我们已经知道适配器模式是如何将一个类的接口转换成另一个复合客户期望的接口，现在我们要看一个改变接口的新模式，但是它改变接口的原因是为了简化接口。这个模式被巧妙地命名为外观模式，之所以这么称呼，是因为它将一个或数个类的复杂的一切都隐藏在背后，只显露一个干净美好的外观。
	
	使用场景：
		1、java的三层开发模式
		2、为复杂的模块或子系统提供外界访问的模块
		3、维护子系统的相对独立
	
## 享元模式(com.design.flyweight)

	面向对象可以非常方便的解决一些扩展性的问题，但是在这个过程中系统务必会产生一些类或者对象，如果系统中存在对象的个数过多时，将导致系统的性能下降。对于这样的问题解决最简单直接的办法就是减少系统中对象的个数。
	
	所谓享元模式就是运行共享技术有效地支持大量细粒度对象的复用。系统使用少量对象，而且这些都比较相似，状态变化小，可以实现对象的多次复用。
	共享模式是支持大量细粒度对象的复用，所以享元模式要求能够共享的对象必须是细粒度对象。
	
	内部状态：在享元对象内部不随外界环境改变而改变的共享部分。
	外部状态：随着环境的改变而改变，不能够共享的状态就是外部状态。
	
	由于享元模式区分了内部状态和外部状态，所以我们可以通过设置不同的外部状态使得相同的对象可以具备一些不同的特性，而内部状态设置为相同部分。 在我们的程序设计过程中，我们可能需要大量细粒度对象来表示对象，如果这些对象除了几个参数不同外其他部分都相同，这个时候我们就可以利用享元模式来大大减少应用程序中的对象。
	内部状态存储于享元对象内部，而外部状态则应该由客户端来考虑。
	
	享元模式存在如下几个角色：
		Flyweight:抽象享元类，所有具体享元类的超类或者接口，通过这个接口，Flyweight可以接受并用于外部专题
		ConcreteFlyweight:具体享元类。指定内部状态，为内部状态增加存储空间。
		UnsharedConcreteFlyweight:非共享具体享元类。指那些不需要共享的Flyweight子类
		FlweightFactory:享元工厂类。用来创建并管理Flyweight对象，它主要用来确保合理的共享Flayweight，当用户请求一个Flyweight时，FlyweightFactory就会提供一个已经创建的Flyweight对象或者新建一个（如果不存在）
		
	享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存改新增对象。
