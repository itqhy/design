# Design (设计模式)

	一、什么是设计模式
	设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、
	让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制
	真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多
	问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问
	题的核心解决方案，这也是设计模式能被广泛应用的原因。
	
	二、设计模式的类型
	根据设计模式的参考书（设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：
			创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。
	1、创建型模式
	这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用新的运算符直接实例化对象。这使得程序在判断针对某个给
	定实例需要创建哪些对象时更加灵活。
	具体包括：
		工厂模式（Factory Pattern）
		抽象工厂模式（Abstract Factory Pattern）
		单例模式（Singleton Pattern）
		建造者模式（Builder Pattern）
		原型模式（Prototype Pattern）
	2、结构型模式
	这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。
	具体包括：
		适配器模式（Adapter Pattern）
		桥接模式（Bridge Pattern）
		过滤器模式（Filter、Criteria Pattern）
		组合模式（Composite Pattern）
		装饰器模式（Decorator Pattern）
		外观模式（Facade Pattern）
		享元模式（Flyweight Pattern）
		代理模式（Proxy Pattern）
	3、行为型模式
	这些设计模式特别关注对象之间的通信。
	具体包括：
		责任链模式（Chain of Responsibility Pattern）
		命令模式（Command Pattern）
		解释器模式（Interpreter Pattern）
		迭代器模式（Iterator Pattern）
		中介者模式（Mediator Pattern）
		备忘录模式（Memento Pattern）
		观察者模式（Observer Pattern）
		状态模式（State Pattern）
		空对象模式（Null Object Pattern）
		策略模式（Strategy Pattern）
		模板模式（Template Pattern）
		访问者模式（Visitor Pattern）
		
	三、设计模式的六大原则
	1、开闭原则（Open Close Principle）
	开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，
	是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。  
	2、里氏代换原则（Liskov Substitution Principle）
	里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的
	基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新
	的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，
	所以里氏代换原则是对实现抽象化的具体步骤的规范。
	3、依赖倒转原则（Dependence Inversion Principle）
	这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。也就是说要把业务尽量封装为接口，而不要在程序
	中直接编写具体实现。
	4、接口隔离原则（Interface Segregation Principle）
	这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计
	模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。
	5、迪米特法则，又称最少知道原则（Demeter Principle）
	最少知道原则是指：一个实体类应当尽量少地与其他实体类之间发生相互作用，使得系统功能模块相对独立。
	6、合成复用原则（Composite Reuse Principle）
	合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。

## 工厂模式  (com.design.factory)

### 分类
	分为三种：
		简单工厂模式
		工厂方法模式
		抽象工厂模式

### 区别
	工厂方法模式：
		一个抽象产品类，可以派生出多个具体产品类
		一个抽象工厂类，可以派生出多个具体工厂类
		每个具体工厂类只能创建一个具体产品类的实例
	抽象工厂模式：
		多个抽象产品类，每个抽象产品类可以派生出多个具体产品类
		一个抽象工厂类，可以派生出多个具体工厂类
		每个具体工厂类可以创建多个具体产品类的实例
	区别：
		工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个
		工厂方法模式具体工厂类智能创建一个具体产品类的实例，而抽象工厂模式可以创建多个
		

## 单例模式 (com.design.singleton)

	分为两种 ：饿汉式 和懒汉式
	懒汉式：指全局的单例实例在第一次被使用时构建。
	饿汉式：指全局的单例实例在类装载时构建。
	

	具体实现：synchornized、双重检查锁定、静态内部类

## 建造者模式(com.design.builder)
	将一个复杂的对象的构建与它的表示分离，是的同样的构建过程可以创建不同的表示。
	工厂类模式提供的是创建单个类的模式，而建造者模式是将各种产品几种起来进行管理，用来创建复合对象，所谓复合对象就是指某
	个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的。
	
	建造者模式通常包括下面几个角色：
	
	1、Builder:给出一个抽象接口，以规范产品对象的各个组成成分的建造，这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。
	2、ConcreteBuilder:实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。在建造的过程完成后，提供产品的实例。
	3、Director:调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，之负责保证对象个部分完整创建或按某种顺序创建。
	4、Product:要创建的复杂对象。
	
	应用实例：
	1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 
	2、JAVA 中的 StringBuilder。
	
	使用场景：
	1、需要生成对象具有复杂的内部结构。
	2、需要生成的对象内部属性本身相互依赖。
	
	与工厂模式的区别是：建造者模式更加关注零件装配的顺序。
	
## 原型模式 (com.design.prototype )

	原型模式是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，他提供了一种创建对象的最佳方式。
	这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，
	一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

	使用场景：
		1、资源优化场景。
		2、类的初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。
		3、性能和安全要求的场景。
		4、通过new产生一个对象需要非常繁琐的数据准备或访问全向，则可以使用原型模式。
		5、一个对象多个修改者的场景。
		6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改值时，可以考虑使用原型模式拷贝多个对象供调用者使用。
		7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone方法创建一个对象，让然后由工厂方法提供给调用者。
		
		
	注意事项：
		与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有的对象生成新的对象，
		浅复制实现Cloneable,重写clone方法，浅复制是通过Serializable读取二进制流。
		
		
	实现方式：
		浅复制实现：浅复制将对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。
		深复制实现： 深复制对象后，不论是基本数据类型还是引用类型都会重新创建，深复制进行了完全彻底的复制，而浅复制不彻底。
		
## 适配器模式(com.design.adapter)

	适配器模式的基本作用是将一个类的接口转换成客户希望的另外一个接口，使得原先由于接口不兼容而不能一起工作的那些类可以在一起工作。
	
	模式中的角色：
		1、目标接口（Target） ：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。
		2、需要适配的类（Adaptee): 需要适配的类或适配者类。
		3、适配器（Adapter):通过包装一个需要适配的对象，把原接口转换成目标接口。
	
	何时使用适配器模式？
		1、系统需要使用现有的类，但此类的接口不符合系统的需要。
		2、想要建立一个可以重复使用的类，用于一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。
		3、通过接口的转换，将一个类插入另一个类系中。
		4、两个类所做的事情相同或相似，但具有不同接口的时候。
		5、旧的系统开发的类已经实现了一些功能，但是客户端却只能以另外接口的形式访问，但我们不希望手动更改现有类的时候。
		6、使用第三方组件，组件接口定义和自己定义的不同，不希望修改自己的接口，但是要使用第三方接口的功能。
		
	应用实例：
		1、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的
		 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 
		2、在 LINUX 上运行 WINDOWS 程序。 
		3、JAVA 中的 jdbc。

## 桥接模式(com.design.bridge)	

	
			
